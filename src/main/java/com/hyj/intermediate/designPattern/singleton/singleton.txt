为什么要使用volidate：
 = new xxx();
 伪代码：
1 memory=allocate();// 分配内存 相当于c的malloc

2 ctorInstanc(memory) //初始化对象

3 instance=memory //设置instance指向刚分配的地址
指令重排：
在132  导致分配内存还没赋值导致不为null

单例模式详细大家都已经非常熟悉了，单例模式的八种写法比较中，对单例模式的概念以及使用场景都做了很不错的说明。

结合文章中的八种单例模式的写法，使用实际的示例，来演示线程安全和效率

既然是实际的示例，那么就首先定义一个业务场景：购票。大家都知道在春运的时候，抢票是非常激烈的。
有可能同一张票就同时又成百上千的人同时在抢。这就对代码逻辑的要求很高了，即不能把同一张票多次出售，也不能出现票号相同的票。

那么，接下来我们就使用单例模式，实现票号的生成。同时呢在这个过程中利用上述文章中的八种单例模式的写法，
来实践这八种单例模式的线程安全性和比较八种单例模式的效率。

既然文章中第三种单例模式（懒汉式）是线程不安全的，那么我就从这个单例模式的实现开始探索一下线程安全。

因为不管是八种单例模式的实现方式的哪一种，票号的生成逻辑都是一样的，所以，在此正式开始之前，为了更方便的编写示例代码，先做一些准备工作：封装票号生成父类代码